<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../favicon.svg">
<title>userver: The Basics</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<link rel="stylesheet" href="../../doxygen-like.css">
<script src="../../highlight.pack.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a class="titlelink" href="../../index.html">userver
   </a>
   </div>
   <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework (beta)</a></div>
  </td>
  <td style="float: right; padding-right: 40px; padding-top: 15px;">
    <a href="https://github.com/userver-framework/userver" rel="noopener" target="_blank" class="titlelink">
      <img src="../../github_logo.svg" alt="Github"/>
    </a>
    &nbsp;
    <a href="https://t.me/+i3k5A6V0oFgwNmYy" rel="noopener" id='telegram_channel' target="_blank" class="titlelink">
      <img src="../../telegram_logo.svg" alt="Telegram"/>
    </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Basics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md137"></a>
Microservices and other I/O-bound applications</h1>
<p>For <a href="https://en.wikipedia.org/wiki/Microservices">microservices</a> waiting for I/O is typical: often the response of a microservice is formed from several responses from other microservices and databases.</p>
<p>The problem of efficient waits for I/O in the classical approach is solved by callbacks: a function (called a callback) is passed to the method that performs I/O, the callback is called by the method when the wait is complete. If you need to perform several I/O operations sequentially, the callback from the first I/O method calls the method for the next I/O and passes the next callback to it. As a result, you get code that is unpleasant to write and difficult to maintain due to the many nested functions and non-obvious control flow.</p>
<p>The userver framework with stackful coroutines comes to the rescue.</p>
<p>For the user of the framework, <b>the code becomes simple and linear, but everything works efficiently</b>:</p>
<div class="fragment"><div class="line">cpp</div>
<div class="line">Response View::Handle(Request&amp;&amp; request, const Dependencies&amp; dependencies) {</div>
<div class="line">  auto cluster = dependencies.pg-&gt;GetCluster();                             // üöÄ</div>
<div class="line">  auto trx = cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster);  // üöÄ</div>
<div class="line"> </div>
<div class="line">  const char* statement = &quot;SELECT ok, baz FROM some WHERE id = $1 LIMIT 1&quot;;</div>
<div class="line">  auto row = psql::Execute(trx, statement, request.id)[0];                  // üöÄ</div>
<div class="line">  if (!row[&quot;ok&quot;].As&lt;bool&gt;()) {</div>
<div class="line">    LOG_DEBUG() &lt;&lt; request.id &lt;&lt; &quot; is not OK of &quot;</div>
<div class="line">                &lt;&lt; GetSomeInfoFromDb();                                     // üöÄ</div>
<div class="line">    return Response400();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar);      // üöÄ</div>
<div class="line">  trx.Commit();                                                             // üöÄ</div>
<div class="line"> </div>
<div class="line">  return Response200{row[&quot;baz&quot;].As&lt;std::string&gt;()};</div>
<div class="line">}</div>
</div><!-- fragment --><p>For the simplicity of the example, all lines where the coroutine can be paused are marked as <code>// üöÄ</code>. In other frameworks or programming languages it is often necessary to explicitly mark the context switch of the coroutine. In those languages in each line with the comment <code>// üöÄ</code>, you would have to write a keyword like <code>await</code>. In userver you do not need to do this, switching occurs automatically and you do not need to think about the implementation details of various methods of the framework.</p>
<p>Unlike in the Python, <b>in userver multiple coroutines can be executed simultaneously on different processor cores</b>. For example the <code>View::Handle</code> may be called in parallel for different requests.</p>
<p>Now compare the above userver code with the classic callback approach: </p><div class="fragment"><div class="line">cpp</div>
<div class="line">void View::Handle(Request&amp;&amp; request, const Dependencies&amp; dependencies, Response response) {</div>
<div class="line">  dependencies.pg-&gt;GetCluster(</div>
<div class="line">    [request = std::move(request), response](auto cluster)</div>
<div class="line">  {</div>
<div class="line">    cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster,</div>
<div class="line">      [request = std::move(request), response](auto&amp; trx)</div>
<div class="line">    {</div>
<div class="line">      const char* statement = &quot;SELECT ok, baz FROM some WHERE id = $1 LIMIT 1&quot;;</div>
<div class="line">      psql::Execute(trx, statement, request.id,</div>
<div class="line">        [request = std::move(request), response, trx = std::move(trx)](auto&amp; res)</div>
<div class="line">      {</div>
<div class="line">        auto row = res[0];</div>
<div class="line">        if (!row[&quot;ok&quot;].As&lt;bool&gt;()) {</div>
<div class="line">          if (LogDebug()) {</div>
<div class="line">              GetSomeInfoFromDb([id = request.id](auto info) {</div>
<div class="line">                  LOG_DEBUG() &lt;&lt; id &lt;&lt; &quot; is not OK of &quot; &lt;&lt; info;</div>
<div class="line">              });</div>
<div class="line">          }</div>
<div class="line">          *response = Response400{};</div>
<div class="line">        }</div>
<div class="line">        psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar,</div>
<div class="line">          [row = std::move(row), trx = std::move(trx), response]()</div>
<div class="line">        {</div>
<div class="line">          trx.Commit([row = std::move(row), response]() {</div>
<div class="line">            *response = Response200{row[&quot;baz&quot;].As&lt;std::string&gt;()};</div>
<div class="line">          });</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">    });</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><p>The classical approach is almost twice as long, and it is difficult to read and maintain because of the deep nesting of the lambda functions. Moreover, the time-consuming error codes handling is completely omitted, while in the first example all the errors are automatically reported through the exception mechanism.</p>
<h1><a class="anchor" id="autotoc_md138"></a>
Coroutines</h1>
<p>In simple terms, coroutines are lightweight threads that are managed by the application itself, not by the operating system.</p>
<p>Coroutines provide an additional benefit in high-load applications:</p><ul>
<li>The OS does not need to know about coroutines, and therefore does not need to use complex and heavy logic to manage them and spend additional system resources.</li>
<li>The application knows how and when it is best to pause or start the coroutine, thus the engine avoids some of the heavy OS context switches.</li>
<li>Switching between coroutines is an easy operation that usually does not require system calls or other heavy operations.</li>
</ul>
<p>However, there is a disadvantage of a cooperative multitasking:</p><ul>
<li>Coroutine scheduler is not preemptive. Poorly written coroutine payloads could occupy the system threads and make the other coroutines starve, but in most cases there are means to make them cooperate better with minimal code changes.</li>
</ul>
<p>The user of the framework does not work directly with the coroutines, but rather works with tasks that are executed on the coroutines. It is very expensive to create and destroy coroutines for each asynchronous operation, so coroutines are reused between tasks. When a new task is starting, a free coroutine is selected to host it. After the task is finished, the coroutine is released, and can be used by another task.</p>
<h1><a class="anchor" id="autotoc_md139"></a>
Performance</h1>
<p>The main purpose of userver is to be an effective solution for IO-bound applications. Coroutines help to achieve that purpose.</p>
<p>It takes less than 1us to invoke and wait for a noop task <code>engine::Async([] () {}).Wait()</code>. In this case, the task execution time will be automatically measured inside the <code><a class="el" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">engine::Async()</a></code>, the task will be linked to the parent task to simplify <a class="el" href="../../de/db6/md_en_userver_logging.html">tracing, all information will be recorded in logs</a>.</p>
<p>For comparison, <code>std::thread ([] () {}).join()</code> takes ~17us and does not provide or log any information.</p>
<p>The userver synchronization primitives are comparable in performance to standard primitives, and we are constantly working to improve them. For example <a class="el" href="../../d3/dfa/core_2src_2engine_2mutex_benchmark_8cpp-example.html">concurrent `lock()` and `unlock()` of the same mutex from different threads on a 2 core system with Hyper-threading</a> produce the following timings:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Competing threads </th><th class="markdownTableHeadNone"><code>std::mutex</code> </th><th class="markdownTableHeadNone"><code>Mutex</code>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">22 ns </td><td class="markdownTableBodyNone">19 ns  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">205 ns </td><td class="markdownTableBodyNone">154 ns  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">403 ns </td><td class="markdownTableBodyNone">669 ns  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md140"></a>
Restrictions</h1>
<p>Usage of <code>catch (...)</code> without <code>throw;</code> <b>should be avoided</b> as the framework may use exceptions not derived from <code>std::exception</code> to manage some resources. Usage of <code>catch</code> with explicit exception type specification (like <code>std::exception</code> or <code>std::runtime_error</code>) is fine without <code>throw;</code>.</p>
<p>The use of synchronization primitives or IO operations of the C++ standard library and libc in the context of coroutine <b>should be avoided</b>.</p>
<p>Userver uses its own coroutine scheduler, which is unknown to the C++ standard library, as well as to the libc. The standard library for synchronization often uses mutexes, other synchronization primitives and event waiting mechanisms that block the current thread. When using userver, this results in the current thread not being able to be used to execute other coroutines. As a result, the number of threads executing coroutines decreases. This can lead to a huge performance drops and increased latencies.</p>
<p>For the reasons described above, the use of synchronization primitives or IO operations of the C++ standard library and libc in the context of coroutine should be avoided. The same goes for all functions and classes that use such synchronization primitives.</p>
<p><b>‚ö†Ô∏èüêô‚ùó Instead of the standard primitives, you need to use the primitives from the userver:</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Standard primitive </th><th class="markdownTableHeadNone">Replacement from userver  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::this_thread::sleep_for()</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../dc/d3f/namespaceengine.html#a3f0a331825dbd69a272a606b7d5006ed" title="Suspends execution for at least a specified amount of time.">engine::SleepFor()</a></code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::this_thread::sleep_until()</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../dc/d3f/namespaceengine.html#a0f84db0357fdd50ce490138d01ec5a51" title="Suspends execution until the specified time point is reached.">engine::SleepUntil()</a></code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::mutex</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks">engine::Mutex</a></code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::condition_variable</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../d3/d5d/classengine_1_1ConditionVariable.html" title="std::condition_variable replacement for asynchronous tasks">engine::ConditionVariable</a></code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::future&lt;T&gt;</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a>&lt;T&gt;</code> or <code><a class="el" href="../../d8/d67/classengine_1_1Future.html" title="std::future replacement for asynchronous tasks that works in pair with engine::Promise">engine::Future</a></code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::async()</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async()</a></code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::thread</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async()</a></code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">network sockets </td><td class="markdownTableBodyNone"><code><a class="el" href="../../dd/dcf/classengine_1_1io_1_1Socket.html" title="Socket representation.">engine::io::Socket</a></code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::filesystem:</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../d5/d8f/namespacefs.html" title="filesystem support">fs</a>::*</code> (but not <code><a class="el" href="../../dc/dcb/namespacefs_1_1blocking.html" title="blocking function and classes to work with filesystem">fs::blocking</a>::*</code>!)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::cout</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../df/d72/logging_2log_8hpp.html#a87d766158e3857c6aedba65e63f24d05" title="Evaluates a message and logs it to the default logger if its level is below or equal to logging::Leve...">LOG_INFO()</a></code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::cerr</code> </td><td class="markdownTableBodyNone"><code><a class="el" href="../../df/d72/logging_2log_8hpp.html#af4286b23b3d2bde3eab2c8bd7131fee4" title="Evaluates a message and logs it to the default logger if its level is below or equal to logging::Leve...">LOG_WARNING()</a></code> and <code><a class="el" href="../../df/d72/logging_2log_8hpp.html#aa14f3fd56b4112420dd49c2ebf8276f1" title="Evaluates a message and logs it to the default logger if its level is below or equal to logging::Leve...">LOG_ERROR()</a></code>  </td></tr>
</table>
<p>An overview of the main synchronization mechanisms is available <a class="el" href="../../d1/d6b/md_en_userver_synchronization.html">on a separate page</a>.</p>
<hr  />
<p> ‚ö†Ô∏èüêô‚ùó If you want to run code that uses standard synchronization primitives (for example, code from a third-party library), then this code should be run in a separate <code>engine::TaskProcessor</code> to avoid starvation of main task processors.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md141"></a>
Tasks</h1>
<p>The asynchronous <b>task</b> (<code><a class="el" href="../../d8/d7c/classengine_1_1Task.html" title="Asynchronous task.">engine::Task</a></code>, <code><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a></code>) can return a result (possibly in form of an exception) or return nothing. In any case, the task has the semantics of future, i.e. you can wait for it and get the result from it.</p>
<p>To create a task call the <code><a class="el" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a></code> function. It accepts the name of a task, the user-defined function to execute, and the arguments of the user-defined function:</p>
<div class="fragment"><div class="line">cpp</div>
<div class="line">auto task = utils::Async(&quot;my_job&quot;, &amp;func, arg1, arg2);</div>
<div class="line">// do something ...</div>
<div class="line">auto result = task.Get();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md142"></a>
Waiting</h1>
<p>The code inside the coroutine may want to wait for an external event - a response from the database, a response from the HTTP client, the arrival of a certain time. If a coroutine wants to wait, it tells the engine that it wants to suspend its execution, and another coroutine starts executing on the current thread of the operating system instead. As a result, the thread is not idle, but reused by other users. After an external event occurs, the coroutine will be scheduled and executed.</p>
<div class="fragment"><div class="line">cpp</div>
<div class="line">f();</div>
<div class="line">engine::SleepFor(std::chrono::seconds(60)); // voluntarily giving the current thread to other coroutines</div>
<div class="line">g(); // The thread has returned to us</div>
</div><!-- fragment --><p><a class="anchor" id="task_cancellation_intro"></a></p>
<h1><a class="anchor" id="autotoc_md143"></a>
Task cancellation</h1>
<p>Task can be notified that it needs to discard its progress and finish early. Cancelling a task restricts the execution of blocking operations in that task.</p>
<p>To cancel a task, just call the <code><a class="el" href="../../d8/d7c/classengine_1_1Task.html#a7571e37ab539ef8cea8c29b69a604779" title="Queues task cancellation request.">engine::Task::RequestCancel()</a></code> or <code><a class="el" href="../../d8/d7c/classengine_1_1Task.html#a96cf988764c95fc158d9a3cf55ffe607" title="Cancels the task and suspends execution until it is finished. Can be called from coroutine context on...">engine::Task::SyncCancel()</a></code> method. It cancels only a single task and does not affect the subtasks that were created by the canceled task. The framework typically reports a wait interrupt either by using a return code (for example, <code>CvStatus</code> for <code><a class="el" href="../../d3/d5d/classengine_1_1ConditionVariable.html#aae663b5b5865e24e5c3aff2a87e954c2">engine::ConditionVariable::Wait</a></code>), or by throwing a module-specific exception (<code>WaitInterruptedException</code> for <code><a class="el" href="../../d8/d7c/classengine_1_1Task.html#a36a919b59746cb2603e7b189c4ac619d" title="Suspends execution until the task finishes or caller is cancelled. Can be called from coroutine conte...">engine::Task::Wait</a></code>).</p>
<p>In addition to explicitly calling <code><a class="el" href="../../d8/d7c/classengine_1_1Task.html#a7571e37ab539ef8cea8c29b69a604779" title="Queues task cancellation request.">engine::Task::RequestCancel()</a></code>, cancellation can occur:</p><ul>
<li>due to application shutdown;</li>
<li>due to the end of the <code><a class="el" href="../../d8/d7c/classengine_1_1Task.html" title="Asynchronous task.">engine::Task</a></code> lifetime;</li>
<li>for other reasons (lack of resources, task hanging, etc.).</li>
</ul>
<p>The user is provided with several mechanisms to control the behavior of the application in case of cancellation:</p><ul>
<li><code><a class="el" href="../../db/df2/cancel_8hpp.html#a8d5e89aac1226c90d4f8e0826ea68256" title="Throws an exception if a cancellation request for this task is pending.">engine::current_task::CancellationPoint()</a></code> &ndash; if the task is canceled, calling this function throws an exception that is not caught during normal exception handling (not inherited from <code>std::exception</code>). This will result in stack unwinding with normal destructor calls for all local objects. <b>‚ö†Ô∏èüêô‚ùó Catching this exception results in UB, your code should not have <code>catch (...)</code> without <code>throw;</code> in the handler body</b>!</li>
<li><code><a class="el" href="../../db/df2/cancel_8hpp.html#aed8fc1cdfd588f3973f5c9bc503c9986">engine::current_task::ShouldCancel()</a></code> and <code><a class="el" href="../../db/df2/cancel_8hpp.html#a561f4b1f4b6d9b12f41a8f6a0d98547e" title="Checks for pending cancellation requests.">engine::current_task::IsCancelRequested()</a></code> &ndash; predicates that return <code>true</code> if the task is canceled:<ul>
<li>by default, use <code><a class="el" href="../../db/df2/cancel_8hpp.html#aed8fc1cdfd588f3973f5c9bc503c9986">engine::current_task::ShouldCancel()</a></code>. It reports that a cancellation was requested for the task and the cancellation was not blocked (see below);</li>
<li><code><a class="el" href="../../db/df2/cancel_8hpp.html#a561f4b1f4b6d9b12f41a8f6a0d98547e" title="Checks for pending cancellation requests.">engine::current_task::IsCancelRequested()</a></code> notifies that the task was canceled even if cancellation was blocked; effectively ignoring caller's requests to complete the task regardless of cancellation.</li>
</ul>
</li>
<li><code><a class="el" href="../../df/d40/classengine_1_1TaskCancellationBlocker.html">engine::TaskCancellationBlocker</a></code> &ndash; scope guard, preventing cancellation in the current task. As long as it is alive all the blocking calls are not interrupted, <code>engine::current_task::CancellationPoint</code> throws no exceptions, <code>engine::current_task::ShouldCancel</code> returns <code>false</code>. <b>‚ö†Ô∏èüêô‚ùó Disabling cancellation does not affect the return value of <code><a class="el" href="../../db/df2/cancel_8hpp.html#a561f4b1f4b6d9b12f41a8f6a0d98547e" title="Checks for pending cancellation requests.">engine::current_task::IsCancelRequested()</a></code>.</b></li>
</ul>
<p>Calling <code><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html#a3b5802799716e29c5cd038fb28a9340d" title="Returns (or rethrows) the result of task invocation. After return from this method the task is not va...">engine::TaskWithResult::Get()</a></code> on a canceled task would wait for task to finish and a <code><a class="el" href="../../d8/dc1/classengine_1_1TaskCancelledException.html" title="Thrown if a TaskWithResult, for which we were waiting, got cancelled.">engine::TaskCancelledException</a></code> exception would be thrown afterwards. For non-canceled tasks the <code><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html#a3b5802799716e29c5cd038fb28a9340d" title="Returns (or rethrows) the result of task invocation. After return from this method the task is not va...">engine::TaskWithResult::Get()</a></code> returns the result of the task.</p>
<p>Note that the destructor of <code><a class="el" href="../../d8/d7c/classengine_1_1Task.html" title="Asynchronous task.">engine::Task</a></code> cancels and waits for task to finish if the task has not finished yet. Use <code><a class="el" href="../../d0/dc7/classconcurrent_1_1BackgroundTaskStorage.html">concurrent::BackgroundTaskStorage</a></code> or <code><a class="el" href="../../d8/d7c/classengine_1_1Task.html#af38546bfc7a0d3b86387980ce48bbb98" title="Detaches task, allowing it to continue execution out of scope.">engine::Task::Detach()</a></code> to continue task execution out of scope. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
<a id='page_edit' style="float:left; padding-left: 7pt;" href="#">‚öí –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É</a>
<address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<script type="text/javascript">
const LOWER_CASE_TRANSLITTERATION_MAPPING = {
    "–∞":"a", "–±":"b", "–≤":"v", "–≥":"g", "–¥":"d", "–µ":"e", "—ë":"jo", "–∂":"zh",
    "–∑":"z", "–∏":"i", "–π":"jj", "–∫":"k", "–ª":"l", "–º":"m", "–Ω":"n", "–æ":"o",
    "–ø":"p", "—Ä":"r", "—Å":"s", "—Ç":"t", "—É":"u", "—Ñ":"f", "—Ö":"x", "—Ü":"c",
    "—á":"ch", "—à":"sh", "—â":"shh", "—ä":"\'", "—ã":"y", "—å":"\'", "—ç":"je",
    "—é":"ju", "—è":"ja"
};
const DOXYGEN_DIAMOND_STRING = '‚óÜ\u00A0' // ‚óÜ&nbsp;
function make_id(raw_id) {
    return raw_id.toLowerCase().split('').map(function (char) {
        return LOWER_CASE_TRANSLITTERATION_MAPPING[char] || char;
    }).join('').replace(/\W/g, '');
}
const html_escape = function () {
    const p = document.createElement('p');
    return function (text) {
        p.textContent = text;
        return p.innerHTML;
    };
}();
function setup_page_edit() {
    let href = window.location.href;
    const idx = href.indexOf('md_ru_');
    if (idx === -1) {
        $('#page_edit').hide();
        return;
    }
    href = href.substring(idx).split('.html')[0];
    href = href.split('#')[0];
    href = href.replace('md_ru_', 'https://wiki.yandex-team.ru/taxi/backend/');
    href = href.replaceAll('_', '/');
    $('#page_edit').attr("href", href + '/.edit');
}
function draw_toc() {
    let headers = $(':header');
    if (headers.length === 0) {
        return;
    }
    let sidenav_content = '<div id="mySidenav" class="sidenav">';
    sidenav_content += '<h2>Table of contents</h2>';
    headers.each(function() {
        let index = parseInt(this.nodeName.substring(1)) - 1;
        const header = $(this);
        let id = header.attr('id');
        if (!id) {
          id = make_id(header.text())
          header.attr('id', id);
        }
        let header_text = header.text()
        if (header_text.startsWith(DOXYGEN_DIAMOND_STRING)) {
            ++index;
            header_text = header_text.substring(DOXYGEN_DIAMOND_STRING.length);
        }
        sidenav_content += ''
          + '<a href="#' + id + '" style="padding-left: ' + index * 15 + 'px">'
          + '‚Ä¢&nbsp;' + html_escape(header_text)
          + '</a>'
        ;
        header.append(' <a class="hoverlink" href="#' + id + '">üîó</a>')
    });
    sidenav_content += '</div>';
    $(sidenav_content).insertAfter('.header');
}
function highlight_code() {
    if (window.location.href.indexOf("pp_source") !== -1
        || window.location.href.indexOf("cpp-example") !== -1) {
        // Header listing is already nicely highlighted by Doxygen
        return;
    }
    hljs.configure({
        tabReplace: '    ' // 4 spaces
    });
    hljs.registerAliases('py', {languageName: 'python'});
    hljs.registerAliases('sh', {languageName: 'shell'});
    hljs.registerAliases('bash', {languageName: 'shell'});
    hljs.registerAliases('yml', {languageName: 'yaml'});
    hljs.registerAliases('plain', {languageName: 'plaintext'});
    hljs.registerAliases('tskv', {languageName: 'plaintext'});
    $(".fragment").each(function() {
        const node = $(this);
        let data = '';
        let language = '';
        let requires_higlighting = true;
        node.children('div.line').each(function(i) {
            line = $(this).text();
            // Doxygen 1.8.11 workaround to remove line numbers.
            // No line numbers added in Doxygen 1.8.13
            line = line.replace(/^ *\d+\xA0/, '');
            if (i === 0) {
                line = line.trimLeft().replace(/^# /, '');
                if (line === 'autodetect') {
                    return true;
                } else if (hljs.getLanguage(line)) {
                    language = line;
                    return true;
                } else {
                    requires_higlighting = false;
                    return false;
                }
            }
            data += line + '\n';
        });
        if (requires_higlighting === false) {
            return;
        }
        if (language !== '') {
            data = hljs.highlight(language, data).value;
        } else {
            data = hljs.highlightAuto(data).value;
        }
        node.replaceWith('<div class="fragment"><pre>' + data + '</pre></div>');
    });
}
function setup_if_landing() {
    if (document.getElementById('landing_logo_id') === null) {
        return false;
    }
    $('#titlearea').hide();
    const main_nav = $('#main-nav')
    main_nav.addClass('main-nav-landing');
    main_nav.append('<hr>');
    $('.header').hide();
    $('body').css('background-color', 'black');
    $('#page_edit').hide();
    return true;
}
function sticky_menu() {
    const main_nav = $('#main-nav');
    const menu_y_position = 94;
    const search_results_window = $('#MSearchResultsWindow');
    var menu_is_sticky = false;
    const stick = function () {
        if ($(this).scrollTop() > menu_y_position) {
            if (menu_is_sticky) return;
            search_results_window.addClass('stickySearchResults');
            main_nav.addClass('stickyHeader');
            menu_is_sticky = true;
        } else {
            if (!menu_is_sticky) return;
            search_results_window.removeClass('stickySearchResults');
            // 'top' property of the results window is computed by Doxygen JS
            // and it may give bad results if the computation is invoked at the
            // middle of the page.
            //
            // Hiding the window. Doxygen will recompute and show it on new
            // user input.
            search_results_window.hide();
            main_nav.removeClass('stickyHeader');
            menu_is_sticky = false;
        }
    };
    stick();  // on page refresh draw the menu on a right position
    $(window).on("scroll", stick);
}
function telegram_channel_language() {
  if (/^ru/.test(navigator.language)) {
    const channel = $('#telegram_channel');
    if (channel) {
      channel.attr('href', 'https://t.me/+AdadhDPVG5xhNWRi');
    }
  }
}
$(function() {
    if (setup_if_landing()) return;
    draw_toc();
    highlight_code();
    setup_page_edit();
    telegram_channel_language();
    sticky_menu();
});
</script>
</body>
</html>
